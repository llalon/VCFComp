---
title: "Project 3"
author: "Liam Lalonde"
date: "17/03/2021"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include, include=FALSE}
library(ggpubr)
setwd("C:/Users/liaml/git/VCFComp/out")
source("../funcs.R")
source("../analysis.R")
```

## Introduction

Variant calling is the process of determining and quantifying genetic variation, in the form of singular nucleotide polymorphisms (SNPs), multi-nucleotide polymorphisms (MNPs), insertions, and deletions (indels), and other complex events,  between 2 or more samples. It has a variety of applications including studies in population genetics (Wright et al, 2019) and clinical studies to determine polygenic risk scores and individuals likeliness/ predisposition to specific diseases such as cancer (Na et al., 2019). 2 commonly used methods for variant calling are bcftools mpileup (Li et al, 2009) and freebayes (Garrison & Marth, 2012). Each of these methods accomplishes the same task however arrive there in different ways. Freebayes is a bayesian, haplotype-based caller which calls variants based on literal sequence reads rather than their precise alignment like mpileup which avoids the problem of identical sequences having multiple alignments, however may increase the number of false positives (Garrison & Marth, 2012). Depending on the desired outcome, one of these methods may be preferable to the other. The following compares performance between each of these methods.

## Methods

Bcftools mpileup version 1.9, and freebayes version 1.2.0 was used to compare. 10 unknown sequences of individual burbot (*lota. lota*) fish were obtained from Mandeville et al. 2014 which were previously aligned to a burbot reference *l. lota* genome (GCA_900302385.1_ASM90030238v1_genomic) using bwa-mem. Read group information was added to each sample using Picard version 2.23.2. The resulting VCFs were filtered by quality, greater than 20 only, using vcffilter, and variant stats, including the number of SNPs, and minor allele frequency was obtained using bcftools and vcftools. Multi-allelic SNPs and indels were not filtered. The full pipeline code can be found at https://github.com/llalon/VCFComp, with only key components shown below, and within the appendix. Computation was done on the compute Canada platform.

Directories, on ComputeCanada Cedar, used for the analysis:

```{bash, eval = FALSE}
#!/bin/bash
ROOT_DIR='/scratch/llalon02/Project3/pthree' # root project path
WORK_DIR=$ROOT_DIR'/work_dir' # 'working dir' where scripts are run from
DATA_DIR=$ROOT_DIR'/data' 
BAM_DIR=$DATA_DIR'/sorted_bams' # sorted bams obtained from previous analysis
VCF_DIR=$DATA_DIR'/vcf' # resulting vcf files
OUT_DIR=$ROOT_DIR'/out' # summary stats
REF=$DATA_DIR'/burbot_reference_genome/GCA_900302385.1_ASM90030238v1_genomic.fna' # reference genome file
SCR_DIR=$ROOT_DIR'/sbatch_scripts' # slurm scripts
```

Adding read groups:

```{bash, eval = FALSE}
#!/bin/bash
... # '...' indicating chuck of full script
# iterating through each of the 10 individual sorted bam files and adding read group information using picard
i=0
for bam in $BAM_DIR/*.sorted.bam; do
    [ -e "$bam" ] || continue

    # iterator for sample number. 1-10
    (( i += 1 ))

    ID=$i
    LB="lib1"
    PU="unit1"
    SM="bb$i" # bb1 - bb10
    FOUT="$(echo $bam | cut -f1 -d'.').sorted.rg.bam" # add .rg to file name to indicate readgroups have been added.

    # generate RG
    java -jar $EBROOTPICARD/picard.jar AddOrReplaceReadGroups \
        I=$bam \
        O=$FOUT \
        RGID=$ID RGLB=$LB RGPL=illumina \
        RGPU=$PU \
        RGSM=$SM

    # re-index
    samtools index $FOUT
done
...
```

Running the variant calling software:

```{bash, eval = FALSE}
#!/bin/bash
...
# running mpileup and freebayes against all 10 individuals to a single vcf

# mpileup
bcftools mpileup -a DP,AD -f $REF $BAM_DIR/*.sorted.bam \
    | bcftools call -m --variants-only \
    > $OUT_DIR'/mpileup_all.vcf'
...    
# freebayes
for bam in $BAM_DIR/*.sorted.rg.bam; do
    echo $bam >> $BAM_LIST # where bam list is a temperary file
done
freebayes -f $REF -L $BAM_LIST > $OUT_DIR'/freebayes_all.vcf'
...
```

Resulting vcfs were filtered by quality:

```{bash, eval = FALSE}
#!/bin/bash
...
# filter out those with 20 or less quality score
for vcf in $VCF_DIR/*.vcf; do
    fout=$vcf.filtrd
    vcffilter -f "QUAL > 20" $vcf > $fout
done
...
```

Filtered vcfs were analyzed using vcftools/bcftools to determine depths, allele frequencies, and the number of SNPs:

```{bash, eval = FALSE}
#!/bin/bash
...
# generate a tsv of SNP number
FOUT=$OUT_DIR/snp_stats.txt
echo "number of SNPS:" >> $FOUT
...
for v in *.filtrd; do
    # 1 file each
    vcftools --vcf $(basename $v) --site-depth -c > $(basename $v).locusdepth.txt # site depth
    vcftools --vcf $(basename $v) --depth -c > $(basename $v).inddepth.txt # individual depth per sample
    vcftools --vcf $(basename $v) --freq -c > $(basename $v).freq.txt # allele frequencies
    ...
    # append the number of SNPs to the tsv (single file)
    echo "$(basename $v)  $(bcftools stats $v | grep "number of SNPs:" | cut -f 4)" >> $FOUT
done
...
```

Find differences in SNPs between each:

```{bash, eval = FALSE}
#!/bin/bash
...
# find different/ overlapping SNPs between the 2 methods. $VCF1 and $VCF2 are freebayes and mpileup respectively

# bgzip vcfs, re index, and run isec on each
bgzip $VCF1 -c > vcf1.gz
bgzip $VCF2 -c > vcf2.gz
bcftools index vcf1.gz
bcftools index vcf2.gz
bcftools isec -p isec vcf1.gz vcf2.gz

# append the number of SNPs to the resulting 4 vcfs to the summary file
for i in isec/*.vcf; do
    echo "$(basename $i)  $(bcftools stats $i | grep "number of SNPs:" | cut -f 4)" >> $FOUT
done
...
```

The resulting data was parsed and analyzed, and plots were generated using R:

```{r, eval = FALSE}
#!/usr/bin/env RScript

### read in the data
# SNP counts - see readme.txt in isec folder for information on files
snp.stats <- read.delim("snp_stats.txt")
snp.stats$file <- sapply(strsplit(snp.stats$number.of.SNPS., "\\s+"), `[`, 1)
snp.stats$count <- as.numeric(sapply(strsplit(snp.stats$number.of.SNPS., "\\s+"), `[`, 2))

# depth
locusdepth.fb <- read.delim("freebayes_all.vcf.filtrd.locusdepth.txt")
locusdepth.mp <- read.delim("mpileup_all.vcf.filtrd.locusdepth.txt")

depth.fb <- read.delim("freebayes_all.vcf.filtrd.inddepth.txt")
depth.mp <- read.delim("mpileup_all.vcf.filtrd.inddepth.txt")

# frequency data
freq.fb <- read.delim("freebayes_all.vcf.filtrd.freq.txt", row.names = NULL)
freq.mp <- read.delim("mpileup_all.vcf.filtrd.freq.txt", row.names = NULL)

names(freq.fb) <- c("CHROM", "POS", "N_ALLELES", " N_CHR", "AF1", "AF2")
names(freq.mp) <- c("CHROM", "POS", "N_ALLELES", " N_CHR", "AF1", "AF2")

freq.fb$FREQ <- as.numeric(sapply(strsplit(freq.fb$AF2, ":"), `[`, 2))
freq.mp$FREQ <- as.numeric(sapply(strsplit(freq.mp$AF2, ":"), `[`, 2))

### Calculate

# MAF 
freq.fb$FREQ <- ifelse(freq.fb$FREQ > 0.5, 1 - freq.fb$FREQ, freq.fb$FREQ)
freq.mp$FREQ <- ifelse(freq.mp$FREQ > 0.5, 1 - freq.mp$FREQ, freq.mp$FREQ)

# sample size
n <- nrow(depth.fb)

### generate plots

# stacked histograms for MAF and mean depth
hist1 <- stack_hists(locusdepth.fb$SUM_DEPTH / n, locusdepth.mp$SUM_DEPTH / n) +
    xlab("Mean Depth per SNP") + xlim(0, 200) + ylim(0, 45000)
hist2 <- stack_hists(freq.fb$FREQ, freq.mp$FREQ) +
    xlab("Minor Allele Frequency")

# venn diagram showing SNPs between each method. See readme.txt in isec folder for information on files
venn1 <- venn_by_counts(snp.stats[3, 3], snp.stats[4, 3], snp.stats[6, 3]) +
    ggtitle("Differences in SNPs between 2 variant calling methods")

# mean depth across individuals for each method
barplot1 <- barplot_by_indiv(depth.fb, depth.mp) +
    xlab("Individual") + ylab("Mean Depth") + labs(fill = "Method")
```

## Results

```{r plot1, echo = FALSE, warning=FALSE, message = FALSE, fig.cap="***Fig 1.*** Distribution of (A) mean depth per SNP, (B) SNPs minor allele frequency, and (C) mean depth per individual for freebayes, and mpileup variant calling methods."}
ggarrange(hist1 + ggtitle("A"),
          hist2 + ggtitle("B"),
          barplot1 + ggtitle("C"),
          ncol = 2, nrow = 2, common.legend = TRUE, legend = "bottom")
```

```{r plot2, echo = FALSE, warning=FALSE, message = FALSE, fig.cap="***Fig 2.*** Differences in the number of SNPs between freebayes, and mpileup."}
venn1
```

Compared to mpileup, freebayes had an overall larger number of SNPs. Freebayes had 106117 total SNPs whereas mpileup had 61846 with 39933 SNPs overlapping between both methods; Freebayes had 34% more SNPs compared to mpileup. (Fig 2). The mean minor allele frequency was 0.133 for freebayes and 0.057 for mpileup with similar distributions (Fig 1B). The distribution of mean SNP depth was similar between both methods, having an overall low depth; freebayes had a higher average depth compared to mpileup (Fig 1A). Lastly, there were no differences in mean depth between individuals sequence samples (Fig 1C).

## Discussion

These results are consistent with previous studies. Freebayes is known to generally produce more variants compared to other variant calling methods including mpileup (Cornish and Guda, 2015; Warden et al, 2014; Hwang et al, 2015), especially when filtering for quality as done in this analysis (Hwang et al, 2015). Both methods had a low distribution of coverage depths which could be due to the lack of filtering, aside from quality scores, or a consequence of using a low-quality assembly, and non-model organism reference. Another consequence of using this reference genome is the inability to compare back to an unbiased whole-genome truth set. Errors such as true/false positives and negatives, and subsequently sensitivity, specificity, and IR/AR errors as described by Hwang et al, 2015 can not be accurately compared. Additionally, using a low-quality reference will increase the global error rate of variant calls and artifacts (Li, 2014). Other filtering that could be conducted in future analysis to gain greater insights into the differences between these variant calling methods could be to filter out artifacts by removing those with too low depths. Lower depth will result in a potentially larger number of false positives (Li, 2014). Additionally, for freebayes, high depth, but low-quality regions can result in copy number variations and hidden duplicates (Li, 2014). Aside from depth, filtering may also be done by minor/major allele frequencies, major allele frequencies close to 1 are related to sequencing errors, however, removing these will also filter out real SNPs (Nielsen et al, 2012). Ultimately, the trade-off between sensitivity and specificity depends on the nature of the experiment/analysis. In cases of polygenic risk score analyses, specificity, and a lower rate of false positives may be preferable. Lastly, it is worth mentioning compute time between each method. For this analysis freebayes took significantly longer to run against the same data compared to mpileup.


## References

ASM90030238v1 - Genome - Assembly - NCBI.

Cornish,A. and Guda,C. (2015) A Comparison of Variant Calling Pipelines Using Genome in a Bottle as a Reference. BioMed Research International, 2015, 1–11.

Garrison,E. and Marth,G. (2012) Haplotype-based variant detection from short-read sequencing. arXiv:1207.3907 [q-bio].

Hwang,S. et al. (2015) Systematic comparison of variant calling pipelines using gold standard personal exome variants. Sci Rep, 5, 17875.

Li,H. et al. (2009) The Sequence Alignment/Map format and SAMtools. Bioinformatics, 25, 2078–2079.

Li,H. (2014) Toward better understanding of artifacts in variant calling from high-coverage samples. Bioinformatics, 30, 2843–2851.

Na,R. et al. (2019) Single-Nucleotide Polymorphism–Based Genetic Risk Score and Patient Age at Prostate Cancer Diagnosis. JAMA Netw Open, 2, e1918145.

Nielsen,R. et al. (2012) SNP Calling, Genotype Calling, and Sample Allele Frequency Estimation from New-Generation Sequencing Data. PLoS ONE, 7, e37558.

Warden,C.D. et al. (2014) Detailed comparison of two popular variant calling packages for exome and targeted exon studies. PeerJ, 2, e600.

Wright,B. et al. (2019) From reference genomes to population genomics: comparing three reference-aligned reduced-representation sequencing pipelines in two wildlife species. BMC Genomics, 20, 453.


## Appendix

funcs.R - Functions used to generate plots:

```{r, eval=FALSE}
#!/usr/bin/env RScript

library(ggplot2)
library(ggvenn)

stack_hists <- function(vector1, vector2, name1 = "freebayes", name2 = "mpileup") {
  # generates a stacked histogram (ggplot2) from 2 vectors
  df1 <- data.frame(name1, vector1)
  df2 <- data.frame(name2, vector2)
  names(df1) <- c("x", "y")
  names(df2) <- c("x", "y")
  df <- rbind(df1, df2)

  gh <- ggplot(df, aes(y, fill = x)) +
    geom_histogram() +
    ylab("Frequency") +
    labs(fill = 'Method')

  return(gh)
}

transform_counts <- function(df) {
  # takes a df containing counts and categories (1/1, 1/0, 0/1) and creates data to generate a venn diagram from.
  # https://stackoverflow.com/questions/26761754/create-venn-diagram-using-existing-counts-in-r
  sets = vector(mode = 'list', length = ncol(df) - 1)
  names(sets) = names(df)[1:(ncol(df) - 1)]
  lastElement = 0
  for (i in 1:nrow(df)) {
    elements = lastElement:(lastElement + df[i, ncol(df)] - 1)
    lastElement = elements[length(elements)] + 1
    for (j in 1:(ncol(df) - 1)) {
      if (df[i, j] == 1) {
        sets[[j]] = c(sets[[j]], elements)
      }
    }
  }
  return(sets)
}

venn_by_counts <- function(count1, count2, common, name1 = "freebayes", name2 = "mpileup") {
  # generates a venn diagram from raw count numbers
  df.counts <- as.data.frame(rbind(c(1, 1, common), c(1, 0, count1), c(0, 1, count2)))
  names(df.counts) <- c(name1, name2, "counts")
  return(ggvenn(transform_counts(df.counts), fill_color = c("red", "blue")))
}

barplot_by_indiv <- function(df1, df2, name1 = "freebayes", name2 = "mpileup") {
  # generates a side by side bar plot (ggplot) from 2 dataframes
  ns <- c(names(df1), "fill")
  df1 <- cbind(df1, rep(name1, nrow(df1)))
  df2 <- cbind(df2, rep(name2, nrow(df2)))
  names(df1) <- ns
  names(df2) <- ns
  df <- rbind(df1, df2)
  gb <- ggplot(data = df, aes(x = INDV, y = MEAN_DEPTH, fill = fill)) +
    geom_bar(stat = "identity", position = position_dodge())

  return(gb)
}
```